% NUR ZIEL SYSTEM (Das was wir entwickeln) WIE wird mit situationen gearbeitet, was wir machen
\section{Architektur}
Um die Studie zu durchzuführen wurden zwei Ansätze implementiert: Der erste Ansatz ist der klassische ECA/IFTTT Ansatz, wie er üblicherweise zu finden ist. Der zweite Ansatz ist situationsbasiert und wurde bisher nicht umfangreich im IoT Bereich dokumentiert. Da die beiden Systeme ähnlich sind, werden die meisten Diagramme und Texte zusammengefasst. Die Unterschiede werden jeweils separat nochmals ausgewiesen.\\
%
Im Folgenden wird die Architektur nach dem 4+1 Modell von Philippe Kruchten aufgezeigt.\footnote{Kruchten, Philippe (1995, November). Architectural Blueprints — The “4+1” View Model of Software Architecture.}
%
\subsection{System Kontext}
Das System Kontext Diagramm zeigt die Schnittstellen zwischen Benutzer, Geräten und Software auf. Die einzelnen Komponenten im Diagramm werden jeweils in einem eigenen Abschnitt erklärt.
%
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=.9\textwidth]{images/system_context_diagram.png}
    \caption[System Kontext Diagramm2]{System Kontext Diagramm}
    \label{fig:system_context_diagram}
  \end{center}
\end{figure}
\\
\\
\textbf{Controller App} \\
Die Controller App wurde im Rahmen des Projekts entwickelt und existiert in zwei Versionen: Als Rule Builder (siehe Kapitel \ref{section:regeln}) und als Situation Builder (siehe Kapitel \ref{section:situationen}). Sie ist die Kernapplikation dieser Arbeit und wird für diese Studie verwendet.\\
Die App holt aus der Samsung Smartthings Cloud die verschiedenen Sensoren, die der Benutzer auf seinem Hub eingerichtet
hat. Mit den Sensoren kann der Benutzer Situationen beziehungsweise Regeln definieren und testen. Mit Hilfe einer Rule Engine werden
die Situationen anhand eines Event neu bewertet.\\[2ex]
%
\textbf{Samsung Cloud App} \\
Die Samsung Cloud stellt eine Programmierumgebung zur Verfügung, um eigene Apps für SmartThings zu entwickeln. In dieser wurde eine neue App erstellt, die als Web-API Dienst für die Controller App dient. Die Cloud App sendet an die Controller App die Events von IoT Geräten und nimmt umgekehrt Zustandsbefehle für die IoT Geräte entgegen.\\[2ex]
\textbf{Samsung Cloud OAuth} \\
Der OAuth Service dient zur Authentifizierung der Benutzer. Dadurch wird auch die Samsung Cloud App berechtigt, auf die IoT Geräte des entsprechenden Benutzers zuzugreifen.\\[2ex]
%
\textbf{IoT Geräte}\\
Die IoT Geräte von Samsung SmartThings müssen vom Benutzer installiert werden. In einem Starter Kit enthalten sind ein Hub (für die Kommunikation in die Cloud), sowie diverse Sensoren die sich an den Hub anmelden.\\[2ex]
%
\textbf{Benutzer} \\
Der Benutzer installiert die IoT Geräte und meldet sich anschliessend am Controller App an. Über OAtuh 2.0 loggt sich der Benutzer an der Samsung Cloud an. Dies hat den Vorteil, dass direkt Zugriff auf seine Geräte erteilt wird, bei entsprechender Erlaubnis, und der Benutzer braucht sich nur ein einziges Passwort zu merken.\\%
Einmal eingeloggt, kann der Benutzer beliebig viele Regeln und Situationen erstellen. Unter anderem kann er Benachrichtigungen konfigurieren, die ihm bei bestimmten Events eine E-Mail senden.\\[2ex]
%
\textbf{Rule Engine} \\
Die vom Benutzer erstellten Regeln oder Situationen werden mittels einer Rule Engine ausgewertet. Bei jedem neuen Event (z.B. Bewegungssensor spricht an), werden in der Datenbank zunächst alle relevanten respektive Zusammenhängenden Situationen und Regeln abgefragt. Diese werden aggregiert und gemeinsam der Rule Engine übergeben. Die Rule Engine gibt als Output an, welche Situationen und Regeln neu zutreffen. Aufgrund dieser Information werden anschliessend Aktionen ausgelöst oder die aktive Situation wird angepasst.
%
\clearpage
%
\subsection{Abstract Workflow}
Der Abstract Workflow zeigt einen Beispielablauf auf für die Erfassung von Regeln beziehungsweise Situationen und wie diese getestet werden.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/workflow_view.png}
    \caption[Abstract Workflow]{Abstract Workflow}
    \label{fig:workflow_view}
  \end{center}
\end{figure}
%
In diesem Ablauf loggt sich der Benutzer zuerst via OAuth in die Controller App ein. Er entscheidet sich im Abschnitt Situationen eine neue Situation zu erstellen. In dem Prozess erstellt er mehrere Regeln und Notifactions um sein gewünschtes Verhalten zu definieren.\\
%
Wenn alle Regeln erstellt sind, kann er die Situationen testen, indem er die IoT Geräte auslöst (z.B. mit Bewegung). Sobald ein Event von den IoT Geräten empfangen wird, prüft die Rule Engine im Hintergrund automatisch die betroffenen Regeln. Wenn eine Regel erfüllt wird, dann wird dessen Aktion ausgelöst.
%
\clearpage
%
\subsection{Process View}
%
Die Process View zeigt auf systemischer Ebene wie die Interaktion zwischen den einzelnen Komponenten abläuft.
%
\subsubsection{Benutzereingabe}
Das folgende Diagramm zeigt den Prozess der Benutzereingabe auf.
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=300pt]{images/process_view_create.png}
    \caption[Process View]{Process View: Benutzereingabe}
    \label{fig:process_view_create}
  \end{center}
\end{figure}
%
\begin{enumerate}
\item Situation/Regel erstellen: Der Benutzer erstellt seine Situationen und Regeln in der GUI der Controller App.
\item Kontrolle Validität: Beim Speichern werden alle Eingaben im Validatormodul auf Korrektheit und Erreichbarkeit überprüft, ggf. wird eine Fehlermeldung zurückgegeben.
\item Datencheck/Duplikatecheck: Das Validatormodul prüft in der Datenbank nach Duplikaten und liest bestehende Regeln und Situationen aus.
\item Speichern: Wenn keine Fehler gefunden wurden, dann werden die neuen Daten in der Datenbank abgelegt.
\end{enumerate}
%
\clearpage
\subsubsection{Eventverarbeitung}
Das folgende Diagramm zeigt die Process View der Eventverarbeitung auf.
%
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=300pt]{images/process_view_events.png}
    \caption[Process View]{Process View: Events}
    \label{fig:process_view_events}
  \end{center}
\end{figure}
%
\begin{enumerate}
\item Event melden: Sobald bei einem IoT Gerät eine Veränderung festgestellt wird (z.B. Bewegungssensor aktiv), wird das via Samsung Cloud an den Event Listener gemeldet.
\item Situation/Regel laden: Der Event Listener lädt sich betroffene Regeln und Situationen aus der Datenbank
\item Berechnung: Die neuen Daten werden an die Rule Engine zur Berechnung der neuen Status übergeben.
\item Resultat: Die Rule Engine sendet veränderte Situationen und Regeln zurück.
\item Events speichern: Die neuen Events und veränderten Situationen/Regeln werden in der Datenbank gespeichert.
\item Aktionen ausführen: Wenn eine Regel zutrifft, wird zudem deren Aktion auf dem betroffenen IoT Gerät ausgeführt.
\end{enumerate}
%
\clearpage
%
\subsection{Physikalische View}
Neben einem eigenem Server, auf dem unsere Applikation läuft, werden verschiedene Things (Sensoren), der Samsung SmartThings Hub und die Samsung Cloud benötigt.\\
%
Die Samsung SmartThings Cloud wird von Samsung bereitgestellt, wie auch der Hub mit seinen Things. Für unsere
Webapplikation braucht es einen Server der JavaScript ausführen kann. Weitere Abhängigkeiten gibt es keine.\\[2ex]
%
Die IOT Geräte kommunizieren via ZigBee mit dem Hub. Der Hub kommuniziert über TCP/IP mit der Samsung Cloud. In der Samsung Cloud können eigene Groovy Apps in einer webbasierten IDE programmiert und bereitgestellt werden. Die Controller App kommuniziert über HTTPS mit der Samsung Cloud, einerseits zum Datenaustausch mit REST, und für die Benutzerauthentifikation mit OAuth 2.0. Die Sqlite3-Datenbank wird mittels SQL-Queries angesprochen. Sqlite3 ist eine in-process Datenbank und wird in einer einzigen Datei gespeichert. Zu Backupzwecken muss lediglich diese Datei gesichert werden.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\textwidth]{images/physical_view.png}
    \caption[Physikalische View]{Physikalische View}
    \label{fig:physical_view}
  \end{center}
\end{figure}
\clearpage
%
\subsection{Development View}
In diesem Kapitel wird erklärt wie der Code aufgebaut ist, wie ein Entwickler ins Projekt einsteigen kann und wie das Deployment abläuft.
%
\subsubsection{Code Organisation}
Der gesamte Code mit Dokumentation wird in einem Git Repository verwaltet. Git ist ein Versionsverwaltungstool. Es zeichnet auf, wer wann welche Änderung an Dateien gemacht hat.\\[2ex]
%
Die Applikation existiert in zwei Varianten. Es wurden Git Tags angelegt für die regelbasierte Variante (Tagname: V1) und die situationsbasierte Variante (Tagname: V2).\\
%
Die Ordnerstruktur des Projekts sieht wie folgt aus:
%
\begin{itemize}
\item bin - NodeJS Startdaten
\item business - Backend Logik für Situationen und Regeln
\item client\_js - Clientseitige JavaScript Dateien
\item controllers - Controllers
\item middlewares - ExpressJS middlewares
\item migrations - Datenbank Schema
\item models - Models
\item report - Dokumentation
\item sass - CSS Regeln
\item seeds - Datenbank Testdaten
\item static - Statische Dateien (Bilder, JS, ...)
\item view - Views
\end{itemize}
%
\clearpage
%
\subsubsection{Code Aufbau}
Der Code ist modular aufgebaut. In \ref{fig:development_view} sind nochmals alle Schnittstellen schematisch gegen innen und zur Samsung Cloud dargestellt.\\
%
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=.7\textwidth]{images/development_view.png}
    \caption[Development View]{Development View}
    \label{fig:development_view}
  \end{center}
\end{figure}
%
\clearpage
%
\subsubsection{Datenbankschemas}
Nachfolgend werden die zwei Datenbankschemas dargestellt. Als Wrstes wird das Schema des regelbasierten Ansatz dargestellt. Danach wird das Schema des situationsbasierten Ansatz anhand den Unterschieden zum regelbasierten Schema vorgestellt.\\[2ex]
%
\textbf{Schema regelbasierte Variante}\\
In Abbildung \ref{fig:dbschema_regeln} wird das Schema für die regelbasierte Variante aufgezeigt. Ein Benutzer (\glqq users\grqq{} Tabelle) hat mehrere IOT Geräte (\glqq devices\grqq). Jedes IOT Gerät hat kann mehrere Funktionalitäten (\glqq capabilities\grqq) besitzen. Dies ergibt eine n:m-Beziehung, die über `capabilities\_devices' aufgelöst wird. Auf der zuletzt genannten Tabelle wird auch der letzte Wert gespeichert, den das Gerät für eine Funktionalität gemeldet hat (z.B. Funktion Thermometer, letzter Wert: 21°C). Ein komplettes Log aller veränderten Werte ist in `events' verfügbar.\\[2ex]
%
Der Benutzer erstellt Regelsätze (\glqq rules\grqq), darin sind mehrere Regeln enthalten (\glqq rule\_entries\grqq). Wenn ein Regelsatz zutrifft, dann werden die zugehörigen Aktionen ausgeführt (\glqq rule\_actions\grqq). Aktionen sind nur auf Funktionalitäten möglich, die steuerbar sind, also einen Command (\glqq commands\grqq) besitzen. Dies ist nicht im Datenbankschema abgedeckt, die Datenintegrität wird für diesen Fall durch die Applikation geprüft.
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\textwidth]{images/dbschema_regeln.png}
    \caption[Datenbankschema regelbasiert]{Datenbankschema regelbasiert}
    \label{fig:dbschema_regeln}
  \end{center}
\end{figure}
\clearpage
%
\textbf{Schema situationsbasierte Variante}\\
Im Unterschied zum letzten Schema ist hier Situationen (\glqq situations\grqq) mit Statuszuständen (\glqq situation\_states\grqq) die belegen, ob eine Situation zutrifft oder nicht. Zudem kann festgelegt werden, von welcher Situation es möglich ist in eine andere Situation zu gelangen (\glqq situation\_transitions\grqq). In den Events (\glqq events\grqq) wird ausserdem festgehalten, ob ein spezifisches Event eine Situationsänderung ausgelöst hat, und wenn ja von welcher in welche Situation.
%
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\textwidth]{images/dbschema_situation.png}
    \caption[Datenbankschema situationsbasiert]{Datenbankschema situationsbasiert}
    \label{fig:dbschema_situation}
  \end{center}
\end{figure}
%
\clearpage
%
\subsubsection{Programmierumgebung}
Als Vorbereitung muss leidiglich NodeJS\footnote{https://nodejs.org/} installiert werden. Weitere Softtware wird nicht zwingend benötigt. Es wird keine spezifische IDE zur Entwicklung vorgeschrieben, jeder Texteditor ist grundsätzlich geeignet. Die Autoren haben Visual Studio Code\footnote{https://code.visualstudio.com/} verwendet. Als Datenbank wird sqlite3\footnote{https://sqlite.org/} verwendet. Dies ist eine Dateibasierte Datenbank und muss nicht separat installiert werden.\\[2ex]
%
Nachdem NodeJS installiert wurde, stehen zwei neue Commands auf der Shell zur Verfügung: \glqq node\grqq zur Ausfühurung von NodeJS Applikationen und \glqq npm\grqq zur Installation von NodeJS-Paketen.\\
Nun müssen die verwendeten Pakete vom Projekt installiert werden, dies geht folgendermassen:
\begin{lstlisting}[caption=Installation der Pakete]
npm install -g knex
npm install
\end{lstlisting}
Diese Commands brauchen einige Minuten bis alle Pakete mit allen Voraussetzungen heruntergeladen wurden.\\
%
Als nächstes wird die Datenbank initialisert:
\begin{lstlisting}[caption=Initialisieren der Datenbank]
NODE_ENV=development knex migrate:latest
\end{lstlisting}

Optional kann die Datenbank noch mit Testdaten abgefüllt werden:
\begin{lstlisting}[caption=Testdaten einfügen]
NODE_ENV=development knex seed:run
\end{lstlisting}

Nun ist die Applikation bereit zum Start:
\begin{lstlisting}[caption=Applikation starten]
NODE_ENV=development DEBUG='ip5:*' npm start
\end{lstlisting}

Die Applikation kann nun auf \textbf{http://localhost:3000} aufgerufen werden.
%
\subsubsection{Deployment}
Für das Deployment wurde ein Dockerfile erstellt. Dieses kann im Hauptordner des Projekts gefunden werden. Im Dockerfile muss die URL des Webservers angegeben werden, danach kann das Dockerfile folgendermassen ausgeführt werden:
\begin{lstlisting}[caption=Docker Container starten]
docker build -t ip5iot .
docker run -d -p 80:3000 ip5iot
\end{lstlisting}
Die Applikation steht nun auf \textbf{http://domain.tld/} zur Verfügung.

\clearpage
